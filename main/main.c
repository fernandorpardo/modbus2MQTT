/** ************************************************************************************************
 *	MODBUS2MQTT  
 *  (c) Fernando R (iambobot.com)
 * 	1.0.0 - April 2025
 * 
 *
 ** ************************************************************************************************
**/

/**
To generate the code 

. $HOME/esp/esp-idf/export.sh
cd ~/esp/MODBUS2MQTT

idf.py set-target esp32

idf.py menuconfig
	
idf.py build


Execute
idf.py -p /dev/ttyUSB0 flash

idf.py -p /dev/ttyUSB0 monitor

idf.py -p /dev/ttyUSB0 flash monitor

Device info
esptool.py --port /dev/ttyUSB0 flash_id


Monitor

press Ctrl+a to print SW info
To exit IDF monitor use the shortcut Ctrl+]
**/

/*
SUBSCRIBE TO THE MESSAGES FROM THIS DEVICE
mosquitto_sub -d -t 'modbus2mqtt/set'
*/

#include <stdio.h>
#include <string.h>			// memset

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/uart.h"
#include "driver/gpio.h"
#include "sdkconfig.h"
#include "esp_log.h"
#include "esp_timer.h"		// esp_timer_get_time()

#include "esp_chip_info.h"
#include "esp_flash.h"
#include "esp_mac.h"

#include "esp_system.h"
#include "esp_vfs.h"
#include "esp_spiffs.h"
#include "nvs_flash.h"

#include "config.h"
#include "cstr.h"
#include "modbus.h"
#include "mqtt.h"
#include "network_lib.h"
#include "sdm120ct.h"
#include "DDSU666H.h"

#define PROJECT_NAME		"modbus2MQTT"
#define PROJECT_LOCATION 	"esp/modbus2MQTT"
#define PROJECT_VERSION		"01.00.00"

/** ***********************************************************************************************
	This SW
	
	Tasks				
	"TCP"				2
	"MQTT"				1	
	"SDM120CT_rx_task"	configMAX_PRIORITIES-1
	"SDM120CT_task"		configMAX_PRIORITIES-1
	"DSU666H_rx_task"	configMAX_PRIORITIES-1

	Priority - a lower numerical value indicates a lower priority, and a higher number indicates a higher priority
	UART tasks have the lowest priotity
	
	What this SW does
	SDM120CT_task - wake up every REQUEST_EVERY_SEC (30 secs) to send one by one the queries in SDM120CT_data_query_list
	through UART_1
	SDM120CT_rx_task - when last response is received then function SDM120CT_querylist_done() is called to generate a MQTT Publish with the data
	from both SDM120CT and DDSU666-H
	Data in the MQTT publish is json format that is generated by SDM120CT_generate_json() and DDSU666H_generate_json()
	DSU666H_rx_task - is the DSU666H sniffer that read the message exchanged between the inverter and the DSU666H

*********************************************************************************************** **/

// Network state machine
bool network_wifi_connected= false;
bool network_tcp_connected= false;
bool network_mqtt_connected= false;
bool network_subscribe_send= false;

static const char *TAG = "SDM120CT";

/**
---------------------------------------------------------------------------------------------------
		
								   UART

---------------------------------------------------------------------------------------------------
**/
/**
	ESP-WROOM-32 (30 pins)
	
				GPIO
	
	UART_NUM_1	SDM120CT
	TX			14
	RX			13
	
	UART_NUM_2	DDSU666-H
	TX			17		U2_TXD
	RX			16		U2_RXD
	

**/

static const int RX_BUF_SIZE = 128;
static const int RX2_BUF_SIZE = 128;

// SDM120CT
void init_uart_1(void) 
{
	// UART 1
	uart_config_t uart_config_1 = {
        .baud_rate = 9600,
        .data_bits = UART_DATA_8_BITS,
        .parity    = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_DEFAULT,
    };
    ESP_ERROR_CHECK(uart_driver_install(UART_NUM_1, RX_BUF_SIZE * 2, 0, 0, NULL, 0));
    ESP_ERROR_CHECK(uart_param_config(UART_NUM_1, &uart_config_1));
	// esp_err_t uart_set_pin(uart_port_t uart_num, int tx_io_num, int rx_io_num, int rts_io_num, int cts_io_num)
    ESP_ERROR_CHECK(uart_set_pin(UART_NUM_1, GPIO_NUM_14, GPIO_NUM_13, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
} // init_uart_1()

// DDSU666-H
void init_uart_2(void) 
{
	// DDSU666-H
	// Huawei inverters communicate in the two-line RS485 mode at baud rates of 4800 bps, 9600 
	// bps, or 19200 bps 
	// Data is transferred in asynchronous RTU mode. Each frame consists of one start bit, eight 
	// payload data bits, one CRC bit, and one stop bit (11 bits in total). 
	
	// UART 2
    uart_config_t uart_config_2 = {
        .baud_rate = 9600,
        .data_bits = UART_DATA_8_BITS,
        .parity    = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_DEFAULT,
    };
    ESP_ERROR_CHECK(uart_driver_install(UART_NUM_2, RX_BUF_SIZE * 2, 0, 0, NULL, 0));
    ESP_ERROR_CHECK(uart_param_config(UART_NUM_2, &uart_config_2));
    ESP_ERROR_CHECK(uart_set_pin(UART_NUM_2, GPIO_NUM_17, GPIO_NUM_16, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
} // init_uart_()



/**
---------------------------------------------------------------------------------------------------
		
								   REPORT (MQTT publish)

---------------------------------------------------------------------------------------------------
**/
static char publish_mess[256];

void SDM120CT_publish(void)
{
	if(network_mqtt_connected)
	{
		SDM120CT_generate_json(publish_mess,sizeof(publish_mess));
		mqtt_publish(net_tcp_send, DEVICE_MQTT_NAME"/set", publish_mess);	
		fprintf(stdout,"mqtt_publish %d bytes\n", strlen(publish_mess));
	}
} // SDM120CT_publish

void DDSU666H_publish(void)
{
	if(network_mqtt_connected)
	{
		DDSU666H_generate_json(publish_mess,sizeof(publish_mess));
		mqtt_publish(net_tcp_send, DEVICE_MQTT_NAME"/set", publish_mess);	
		fprintf(stdout,"mqtt_publish %d bytes\n", strlen(publish_mess));
	}
} // DDSU666H_publish

void SDM120CT_querylist_done(void)
{
	printf("\n");
	if(SDM120CT_sequence_phase == INFO)
	{
		SDM120CT_info_printf();
	}
	else
	{
		SDM120CT_printf();
		DDSU666H_printf();
		
		SDM120CT_publish();
		DDSU666H_publish();
	}
} // SDM120CT_querylist_done

/**
---------------------------------------------------------------------------------------------------
		
								   DDSU666-H

---------------------------------------------------------------------------------------------------
**/
void DDSU666H_RX_task(void *arg)
{
    static const char *RX_TASK_TAG = "RX_TASK";
    esp_log_level_set(RX_TASK_TAG, ESP_LOG_INFO);
    uint8_t* data = (uint8_t*) malloc(RX2_BUF_SIZE);
    while (1) {
        int rxBytes = uart_read_bytes(UART_NUM_2, data, RX2_BUF_SIZE, 200 / portTICK_PERIOD_MS);
        if (rxBytes > 0) 
		{		
			int ix=0;
			do {
				ix= DDSU666H_rxdata_process( data, rxBytes, ix);
			} while( ix != 0 && ix <rxBytes);
        }
    }
    free(data);
} // DDSU666H_RX_task

/**
---------------------------------------------------------------------------------------------------
		
								   SDM120CT

---------------------------------------------------------------------------------------------------
**/
int SDM120CT_query_index;
uint16_t *SDM120CT_query_list;
const uint16_t SDM120CT_data_query_list[]= {SDM120CT_REG_VOLTAGE, SDM120CT_REG_CURRENT, SDM120CT_REG_ACTIVEPOWER, SDM120CT_REG_APPARENTPOWER, SDM120CT_REG_REACTIVEPOWER, SDM120CT_REG_POWERFACTOR, SDM120CT_REG_FRECUENCY, 0xFFFF};
const uint16_t SDM120CT_deviceinfo_query_list[]= {SDM120CT_REG_METERID, SDM120CT_REG_BAUDRATE, SDM120CT_REG_SERIALNUMBER, SDM120CT_REG_METERCODE, SDM120CT_REG_SOFTWAREVERSION, 0xFFFF};
int SDM120CT_send_query();

int64_t t0;
#define LOOP_DELAY_MS		1000
#define SEC2LOOPS(x)		(x * 1000/LOOP_DELAY_MS)
#define REQUEST_EVERY_SEC	SEC2LOOPS(30)	// Send the query list every x seconds

void SDM120CT_task(void *arg)
{
	int request_time_sec= 0;
	while (1) 
	{
		if( -- request_time_sec <= 0 )
		{
			request_time_sec= REQUEST_EVERY_SEC;
			SDM120CT_query_index= 0;
			SDM120CT_send_query();
		}
		// vTaskDelay() - Delays a task for a given number of ticks
		// portTICK_PERIOD_MS - one tick period in milliseconds. The unit of portTICK_PERIOD_MS is milliseconds/ticks
		vTaskDelay(1000 / portTICK_PERIOD_MS);	 // 1.000 ms = 1 sec 		
	}
} // SDM120CT_task

void SDM120CT_RX_task(void *arg)
{
    static const char *RX_TASK_TAG = "RX_TASK";
    esp_log_level_set(RX_TASK_TAG, ESP_LOG_INFO);
    uint8_t* data = (uint8_t*) malloc(RX_BUF_SIZE);
    while (1) {
        int rxBytes = uart_read_bytes(UART_NUM_1, data, RX_BUF_SIZE, 200 / portTICK_PERIOD_MS);
        if (rxBytes > 0) 
		{		
			uint8_t Byte_Count= rxBytes>2? data[2] : 0;
			if(Byte_Count+2 == rxBytes-3)
			{
				int64_t t1= esp_timer_get_time();
				uint16_t ErrorCheck= data[8]<<8 | data[7];
				uint16_t crc= CRC16( data, rxBytes - 2);
				if(crc == ErrorCheck)
				{
					// SDM120CT_query_index == -1 means it is not a response to my request but traffic sniffed 
					if(SDM120CT_query_index >= 0)
					{
						SDM120CT_rxdata_process(SDM120CT_query_list[SDM120CT_query_index], data);
						if(_VERBOSE_) printf(" (elapsed %lld ms)", (t1 - t0) / 1000);	
						SDM120CT_query_index ++;
						if(SDM120CT_send_query() == 1) 
						{
							SDM120CT_query_index= 0; 
							SDM120CT_send_query();
						}
					}
				}
				else
					printf("\nERROR: CRC16 0x%4X  ErrorCheck 0x%4X", crc, ErrorCheck);
			}
			else
				printf("\nERROR: Byte_Count %d bytes", Byte_Count);
			fflush(stdout);
        }
    }
    free(data);
} // SDM120CT_RX_task

int SDM120CT_send_query()
{
	if(SDM120CT_query_index<0 || SDM120CT_query_list[SDM120CT_query_index] == 0xFFFF)
	{
		if(SDM120CT_query_list[SDM120CT_query_index] == 0xFFFF) SDM120CT_querylist_done();
		SDM120CT_query_index= -1;
		int r= (SDM120CT_sequence_phase == INFO) ? 1 : 0;
		SDM120CT_sequence_phase= DATA;
		SDM120CT_query_list= ( uint16_t *) &SDM120CT_data_query_list;
		return r;
	}
	if(SDM120CT_sequence_phase == INFO)
	{
		modbus_holding_parameter_query_type query = MODBUS_HOLDING_PARAMETER_DEFAULT(SDM120CT_deviceinfo_query_list[SDM120CT_query_index]);
		query.Error_Check= CRC16( (uint8_t *) &query, sizeof(query) - 2 );
		char *q= (char*)&query;
		size_t sz= sizeof(query);
		t0= esp_timer_get_time();
		int txBytes= uart_write_bytes(UART_NUM_1, q, sz);
		if(txBytes != (int) sz) printf("\n[ERROR] SDM120CT_send_queryTx uart_write_bytes %2d bytes", txBytes);	
	}
	else
	{
		modbus_master_query_type query = MODBUS_QUERY_DEFAULT(SDM120CT_data_query_list[SDM120CT_query_index]);
		query.Error_Check= CRC16( (uint8_t *) &query, sizeof(query) - 2 );
		char *q= (char*)&query;
		size_t sz= sizeof(query);
		t0= esp_timer_get_time();
		int txBytes= uart_write_bytes(UART_NUM_1, q, sz);
		if(txBytes != (int) sz) printf("\n[ERROR] SDM120CT_send_queryTx uart_write_bytes %2d bytes", txBytes);
	}
	return 0;	
} // SDM120CT_send_query


/**
---------------------------------------------------------------------------------------------------
		
								   TCP

---------------------------------------------------------------------------------------------------
**/
// Network CALLBACK
// manage WiFi / TCP events
int NetworkCallback (int status)
{
	switch(status)
	{
		case NETWORK_STATUS_WIFI_CONNECTED:
			{			
				// (1) CONNECTION WIFI
				network_wifi_connected= true;
				network_tcp_connected= false;
				network_mqtt_connected= false;
				network_subscribe_send= false;				
				fprintf(stdout,"[NetworkCallback] (1) CONNECTION WIFI\n");
			}
			break;
		case NETWORK_STATUS_SOCKET_CLOSED:
			{
				network_tcp_connected= false;
				network_mqtt_connected= false;
				network_subscribe_send= false;		
				fprintf(stdout,"[NetworkCallback] (0) CONNECTION CLOSED\n");				
			}
			break;
		default:
			fprintf(stdout, "[NetworkCallback] ERROR DEFAULT\n");	
			fflush(stdout);	
	}
	return 0;
} // NetworkCallback()

// TCP task
void xTask_net_tcp_listener(void *pvParameters)
{
	network_tcp_connected= false;
	char rx_buffer[512];

	while (1)
	{
		if(!network_wifi_connected)
		{
			// Wait for wifi
			vTaskDelay(1000 / portTICK_PERIOD_MS);
		}
		else			
		{
			if(!network_tcp_connected)
			{
				if( net_tcp_connect() == 0)
				{
					// (2) CONNECTION TCP
					network_tcp_connected= true;
					network_mqtt_connected= false;
					network_subscribe_send= false;
					fprintf(stdout,"(2) CONNECTION TCP\n");
				}
				else
				{
					fprintf(stdout, "[xTask_net_tcp_listener] net_tcp_connect FAILED !!! Retry in 3 sec...\n");
					fflush(stdout);	
					vTaskDelay(3000 / portTICK_PERIOD_MS);
				}
			}
			else
			{
				// Process TCP messages
				int n;
				if( (n=net_tcp_receive(rx_buffer, sizeof(rx_buffer))) > 0 )
				{
					char Control_Packet_type= 0;
					mqtt_decode(&Control_Packet_type, rx_buffer, n);
					// if TCP message is an MQTT messages (Control_Packet_type != 0)
					// the process it
					if(Control_Packet_type == CONNACK)
					{
						// (3) CONNECTION MQTT
						network_mqtt_connected= true;
						network_subscribe_send= false;		
						fprintf(stdout,"(3) CONNECTION MQTT\n");						
					}
					else if(Control_Packet_type == PINGRESP)
					{
						// Do nothing					
					}					
					// if _SELF_SUBSCRIBE_ then the device gets their own published messages (meant for testing pourposes)
					else if(Control_Packet_type == SUBACK)
					{
						// (4) CONNECTION SUBSCRIBED	
						fprintf(stdout,"(4) CONNECTION SUBSCRIBED\n");						
					}					
					else if(Control_Packet_type == PUBLISH)
					{
						fprintf(stdout, "\n\nPUBLISH\n");
						char topic[64];
						char payload[256];
						mqtt_payload(&Control_Packet_type, rx_buffer, n, topic, payload, sizeof(payload));	
						fprintf(stdout,"topic   %s\n", topic);			
						fprintf(stdout,"payload %s\n", payload);
						// is it for me (this device)
						if(strcmp(topic, DEVICE_MQTT_NAME"/set") == 0)
						{
							fprintf(stdout,"IT IS FOR ME\n");
							fflush(stdout);
							if(_VERBOSE_)
							{
								cstr_dump(rx_buffer, n);
								printf("\n");
								fflush(stdout);	
							}
						}	
					}
				}
				vTaskDelay(20 / portTICK_PERIOD_MS);
			}
		} // wait for WiFi
	} // while task
} // xTask_net_tcp_listener()

	
/**
---------------------------------------------------------------------------------------------------
		
								   MQTT CLIENT

---------------------------------------------------------------------------------------------------
**/
void xTask_mqtt_client(void *pvParameters)
{
	int count=0;
	while(1)
	{
		if(network_tcp_connected)
		{
			if(!network_mqtt_connected)
			{
				if(count<=0)
				{
					printf("[xTask_mqtt_client] Sending MQTT CONNECT\n"); 
					fflush(stdout);
					mqtt_connect(net_tcp_send);
					//vTaskDelay(1000 / portTICK_PERIOD_MS);
					count= 3;
				}
				else count --;
				
				network_subscribe_send= false;
			}
			else if(!network_subscribe_send)
			{
				network_subscribe_send= true;
				if(_SELF_SUBSCRIBE_)
				{
					printf("[xTask_mqtt_client] Sending MQTT mqtt_subscribe\n"); 
					fflush(stdout);
					mqtt_subscribe(net_tcp_send, 1, DEVICE_MQTT_NAME"/set");
					fprintf(stdout,"mqtt_subscribe\n");
				}
				count= MQTT_PINGREQ_TIME;
			}
			else
			{
				if(count<=0)
				{
					printf("[xTask_mqtt_client] Sending MQTT PING\n"); 
					fflush(stdout);
					mqtt_ping(net_tcp_send);
					count= MQTT_PINGREQ_TIME;
				}
				else count --;
			}
		}
		else 
		{
			count= 0;
			network_mqtt_connected= false;
			network_subscribe_send= false;
		}
		
		vTaskDelay(1000 / portTICK_PERIOD_MS);
		
		fprintf(stdout, "\b\b\b*%2d",count); 
		fflush(stdout);
	}
} // mqtt_client()		
		
		
		
/**
---------------------------------------------------------------------------------------------------
		
								   CONSOLE INFO

---------------------------------------------------------------------------------------------------
**/
void PROJECTInfo(void)
{
	fprintf(stdout, "\n\n");
	fprintf(stdout, "[%s] SW     --------------------------------\n", TAG);
	fprintf(stdout, "   %s\n", PROJECT_NAME);
	fprintf(stdout, "   %s\n", PROJECT_LOCATION);
	fprintf(stdout, "   %s\n", PROJECT_VERSION);
} // PROJECTInfo()

void SystemInfo(void)
{
	fprintf(stdout, "\n\n");
	fprintf(stdout, "[%s] SYSTEM --------------------------------\n", TAG);
	// Print chip information
	esp_chip_info_t chip_info;
	uint32_t flash_size;
	esp_chip_info(&chip_info);
	fprintf(stdout, "   This is %s chip with %d CPU core(s), %s%s%s%s\n",
		   CONFIG_IDF_TARGET,
		   chip_info.cores,
		   (chip_info.features & CHIP_FEATURE_WIFI_BGN) ? "WiFi/" : "",
		   (chip_info.features & CHIP_FEATURE_BT) ? "BT" : "",
		   (chip_info.features & CHIP_FEATURE_BLE) ? "BLE" : "",
		   (chip_info.features & CHIP_FEATURE_IEEE802154) ? ", 802.15.4 (Zigbee/Thread)" : "");

	unsigned major_rev = chip_info.revision / 100;
	unsigned minor_rev = chip_info.revision % 100;
	fprintf(stdout, "   silicon revision v%d.%d\n", major_rev, minor_rev);
	if(esp_flash_get_size(NULL, &flash_size) != ESP_OK) {
		fprintf(stdout, "Get flash size failed\n");
		return;
	}

	fprintf(stdout, "   %" PRIu32 "MB %s flash\n", flash_size / (uint32_t)(1024 * 1024),
		   (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? "embedded" : "external");

	fprintf(stdout, "   Minimum free heap size: %" PRIu32 " bytes\n", esp_get_minimum_free_heap_size());
	fflush(stdout);
	
	// MAC
    unsigned char mac_base[6] = {0};
 //   esp_efuse_mac_get_default(mac_base);
    ESP_ERROR_CHECK(esp_read_mac(mac_base, ESP_MAC_WIFI_STA));
	fprintf(stdout, "   MAC %02X:%02X:%02X:%02X:%02X:%02X\n", mac_base[0],mac_base[1],mac_base[2],mac_base[3],mac_base[4],mac_base[5]);
} // SystemInfo()

/**
---------------------------------------------------------------------------------------------------
		
								   MAIN

---------------------------------------------------------------------------------------------------
**/
void app_main(void)
{
	ESP_LOGI(TAG, "app_main");
	
	// Data init
	SDM120CT_data_init();
	DDSU666H_data_init();

  	SDM120CT_query_index= -1,
	SDM120CT_sequence_phase= INFO;
 	SDM120CT_query_list= ( uint16_t *) &SDM120CT_deviceinfo_query_list;
	
    // Initialize NVS
	// NVS is needed for the WiFi library	
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);	
	// (END) NVS -------------------------
	
	// Console print SW project info
	PROJECTInfo();
	
	// Console print System info
 	SystemInfo();
	fprintf(stdout, "   Free heap size: %"PRIu32"\n", esp_get_free_heap_size());	
	
	// --------------------------------------------------------------------------------------------
	// INIT serial interfaces
	// DDSU666-H
	init_uart_2();
	// SDM120CT
    init_uart_1();
	
	// --------------------------------------------------------------------------------------------
	// NETWORK START
	network_init(NetworkCallback);	
	fprintf(stdout,  "\nConnecting ...\n");
	// WIFI
    ESP_LOGI(TAG, "ESP_WIFI_MODE_STA");	
	wifi_init_sta();
	
	// --------------------------------------------------------------------------------------------
	// TASK
	// TCP
	xTaskCreate(xTask_net_tcp_listener, "TCP", 8*1024, NULL, 2, NULL);
	
	// --------------------------------------------------------------------------------------------
	// TASK
	// MQTT
	xTaskCreate(xTask_mqtt_client, "MQTT", 8*1024, NULL, 1, NULL);		
	
	// --------------------------------------------------------------------------------------------
	// TASK
	// SDM120CT serial
    xTaskCreate(SDM120CT_RX_task, "SDM120CT_rx_task", 4*1024, NULL, configMAX_PRIORITIES-1, NULL);
	xTaskCreate(SDM120CT_task, "SDM120CT_task", 4*1024, NULL, configMAX_PRIORITIES-1, NULL);

    xTaskCreate(DDSU666H_RX_task, "DSU666H_rx_task", 4*1024, NULL, configMAX_PRIORITIES-1, NULL);

	while(1)
	{
		int c= getchar();
		if(c>0)
		{
			// Ctrl+a
			if(c==0x01)
			{
				PROJECTInfo();
				SystemInfo();
				SDM120CT_info_printf();
				SDM120CT_printf();
				DDSU666H_printf();	
				fflush(stdout);
			}
			else {
				fprintf(stdout, "\ncommmand is %c (0x%x)\n", c, c);
				fflush(stdout);
			}
		}
		vTaskDelay(1000 / portTICK_PERIOD_MS);
	}
} // app_main

// END OF FILE